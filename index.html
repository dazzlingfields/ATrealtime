// ================== v4.31 - Realtime Vehicle Tracking ==================
// Features: fast load, AM pairing, bus types, AT-specific occupancy, bikes allowed,
// persistent caching, headsign fallback + backfill, selectable basemaps

// --- API endpoints ---
const proxyBaseUrl = "https://atrealtime.vercel.app";
const realtimeUrl  = `${proxyBaseUrl}/api/realtime`;
const routesUrl    = `${proxyBaseUrl}/api/routes`;
const tripsUrl     = `${proxyBaseUrl}/api/trips`;
const busTypesUrl  = "https://raw.githubusercontent.com/dazzlingfields/ATrealtime/refs/heads/main/busTypes.json";

// --- Map initialization ---
const light = L.tileLayer("https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png", {
  attribution: "&copy; OpenStreetMap contributors &copy; CARTO", subdomains: "abcd", maxZoom: 20
});
const dark = L.tileLayer("https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png", {
  attribution: "&copy; OpenStreetMap contributors &copy; CARTO", subdomains: "abcd", maxZoom: 20
});
const osm = L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
  attribution: "&copy; OpenStreetMap contributors"
});
const satellite = L.tileLayer("https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}", {
  attribution: "Tiles Â© Esri"
});

const map = L.map("map", {
  center: [-36.8485, 174.7633], zoom: 12, layers: [light], zoomControl: false
});
const baseMaps = { "Light": light, "Dark": dark, "OSM": osm, "Satellite": satellite };

const vehicleLayers = {
  bus: L.layerGroup().addTo(map),
  train: L.layerGroup().addTo(map),
  ferry: L.layerGroup().addTo(map),
  out: L.layerGroup().addTo(map)
};
const overlayMaps = {
  "Buses": vehicleLayers.bus,
  "Trains": vehicleLayers.train,
  "Ferries": vehicleLayers.ferry,
  "Out of Service": vehicleLayers.out
};
L.control.layers(baseMaps, overlayMaps).addTo(map);

// --- Data ---
const vehicleMarkers = {};
const tripCache = {};
let routes = {};
let busTypes = {};
const debugBox = document.getElementById("debug");

// --- Colours ---
const vehicleColors = { bus: "#4a90e2", train: "#d0021b", ferry: "#1abc9c", out: "#9b9b9b" };
const trainLineColors = { STH: "#d0021b", WEST: "#417505", EAST: "#f8e71c", ONE: "#4a90e2" };

// --- Occupancy labels ---
const occupancyLabels = [
  "Empty","Many Seats Available","Few Seats Available",
  "Standing Room Only","Limited Standing Room","Full","Not accepting passengers"
];

// --- Helpers ---
async function safeFetch(url) {
  try {
    const res = await fetch(url);
    if (!res.ok) throw new Error(`${res.status} ${res.statusText}`);
    return await res.json();
  } catch (err) {
    console.error("Fetch error:", err);
    debugBox.textContent = `Fetch error: ${err.message}`;
    return null;
  }
}

function addVehicleMarker(id, lat, lon, popupContent, color, type, tripId) {
  if (vehicleMarkers[id]) {
    vehicleMarkers[id].setLatLng([lat, lon]);
    vehicleMarkers[id].setPopupContent(popupContent);
    vehicleMarkers[id].setStyle({ fillColor: color });
    vehicleMarkers[id].tripId = tripId;
  } else {
    const marker = L.circleMarker([lat, lon], {
      radius: 6, fillColor: color, color: "#000",
      weight: 1, opacity: 1, fillOpacity: 0.9
    }).addTo(vehicleLayers[type] || vehicleLayers.out);
    marker.bindPopup(popupContent, { maxWidth: 300 });
    marker.tripId = tripId;
    vehicleMarkers[id] = marker;
  }
}

function buildPopup(routeName, destination, vehicleLabel, busType, licensePlate, speedKmh, occupancy, bikesLine) {
  return `
    <b>Route:</b> ${routeName}<br>
    <b>Destination:</b> ${destination}<br>
    <b>Vehicle:</b> ${vehicleLabel}<br>
    ${busType ? `<b>Bus Model:</b> ${busType}<br>` : ""}
    <b>Number Plate:</b> ${licensePlate}<br>
    <b>Speed:</b> ${(speedKmh >= 0 && speedKmh <= 180 ? speedKmh.toFixed(1) : "N/A")} km/h<br>
    <b>Occupancy:</b> ${occupancy}
    ${bikesLine}
  `;
}

function updateVehicleCount() {
  const busCount = Object.values(vehicleMarkers).filter(m => m.options.fillColor === vehicleColors.bus).length;
  const trainCount = Object.values(vehicleMarkers).filter(m => m.options.fillColor !== vehicleColors.bus && m.options.fillColor !== vehicleColors.ferry && m.options.fillColor !== vehicleColors.out).length;
  const ferryCount = Object.values(vehicleMarkers).filter(m => m.options.fillColor === vehicleColors.ferry).length;
  document.getElementById("vehicle-count").textContent = `Buses: ${busCount}, Trains: ${trainCount}, Ferries: ${ferryCount}`;
}

// --- Trips batch fetch ---
async function fetchTripsBatch(tripIds) {
  const idsToFetch = tripIds.filter(tid => tid && !tripCache[tid]);
  if (idsToFetch.length === 0) return;
  const tripJson = await safeFetch(`${tripsUrl}?ids=${idsToFetch.join(",")}`);
  if (tripJson?.data?.length > 0) {
    tripJson.data.forEach(t => {
      const attrs = t.attributes;
      if (attrs) {
        tripCache[attrs.trip_id] = {
          trip_id: attrs.trip_id,
          trip_headsign: attrs.trip_headsign || "N/A",
          route_id: attrs.route_id,
          bikes_allowed: attrs.bikes_allowed
        };
      }
    });
  }
}

// --- AM train pairing ---
function pairAMTrains(inService, outOfService) {
  const pairs = [];
  const usedOut = new Set();
  inService.forEach(inTrain => {
    let bestMatch = null, bestDist = Infinity;
    outOfService.forEach(o => {
      if (usedOut.has(o.vehicleId)) return;
      const dx = inTrain.lat - o.lat;
      const dy = inTrain.lon - o.lon;
      const dist = Math.sqrt(dx * dx + dy * dy) * 111000;
      if (dist <= 200 && Math.abs(inTrain.speedKmh - o.speedKmh) <= 15) {
        if (dist < bestDist) { bestDist = dist; bestMatch = o; }
      }
    });
    if (bestMatch) {
      usedOut.add(bestMatch.vehicleId);
      pairs.push({ inTrain, outTrain: bestMatch });
    }
  });
  return pairs;
}

// --- Render cached snapshot ---
function renderFromCache(cachedVehicles) {
  if (!cachedVehicles) return;
  cachedVehicles.forEach(v => {
    addVehicleMarker(v.vehicleId, v.lat, v.lon, v.popupContent, v.color, v.typeKey, v.tripId);
  });
  debugBox.textContent = `Showing cached data (last update: ${new Date(cachedVehicles[0]?.ts || Date.now()).toLocaleTimeString()})`;
  updateVehicleCount();
}

// --- Fetch vehicles live ---
async function fetchVehicles() {
  const json = await safeFetch(realtimeUrl);
  if (!json) return;
  const vehicles = json?.response?.entity || json?.entity || [];
  const newVehicleIds = new Set();
  const inServiceAM = [], outOfServiceAM = [];
  const allTripIds = [];
  const cachedState = [];

  vehicles.forEach(v => {
    const vehicleId = v.vehicle?.vehicle?.id;
    if (!v.vehicle || !v.vehicle.position || !vehicleId) return;
    newVehicleIds.add(vehicleId);

    const lat = v.vehicle.position.latitude;
    const lon = v.vehicle.position.longitude;
    const vehicleLabel = v.vehicle.vehicle?.label || "N/A";
    const operator = v.vehicle.vehicle?.operator_id || vehicleLabel.slice(0, 2);
    const vehicleNumber = Number(vehicleLabel) || Number(vehicleLabel.slice(2)) || 0;
    const licensePlate = v.vehicle.vehicle?.license_plate || "N/A";
    const speedKmh = v.vehicle.position.speed ? v.vehicle.position.speed * 3.6 : 0;

    // --- Occupancy (AT-specific) ---
    let occupancy = "N/A";
    if (v.vehicle.occupancy_status !== undefined) {
      const occIdx = v.vehicle.occupancy_status;
      if (occIdx >= 0 && occIdx <= 6) occupancy = occupancyLabels[occIdx];
    } else if (v.trip_update?.occupancy_status !== undefined) {
      const occIdx = v.trip_update.occupancy_status;
      if (occIdx >= 0 && occIdx <= 6) occupancy = occupancyLabels[occIdx];
    }

    let typeKey = "out", color = vehicleColors.out;
    let routeName = "Out of Service", destination = "Unknown";
    const routeId = v.vehicle?.trip?.route_id;
    if (routeId && routes[routeId]) {
      const r = routes[routeId];
      routeName = r.route_short_name || r.route_long_name || "Unknown";
      switch (r.route_type) {
        case 2: typeKey = "train"; break;
        case 3: typeKey = "bus"; break;
        case 4: typeKey = "ferry"; break;
      }
      color = (r.route_color && typeKey === "train") ? `#${r.route_color}` : vehicleColors[typeKey] || color;
    }

    const tripId = v.vehicle?.trip?.trip_id;
    if (tripId) allTripIds.push(tripId);

    // Destination (cached headsign or fallback route)
    if (tripId && tripCache[tripId]?.trip_headsign) {
      destination = tripCache[tripId].trip_headsign;
    } else if (routes[routeId]) {
      destination = routes[routeId].route_long_name || routes[routeId].route_short_name || "Unknown";
    }

    // Bikes allowed
    let bikesLine = "";
    const tripData = tripId ? tripCache[tripId] : null;
    if (tripData?.bikes_allowed !== undefined) {
      if (typeKey === "bus" && tripData.bikes_allowed === 2) bikesLine = `<br><b>Bikes Allowed:</b> Yes`;
      if (typeKey === "train") {
        if (tripData.bikes_allowed === 2) bikesLine = `<br><b>Bikes Allowed:</b> Yes`;
        else if (tripData.bikes_allowed === 1) bikesLine = `<br><b>Bikes Allowed:</b> Some`;
      }
    }

    // Bus type
    let busType = "";
    if (typeKey === "bus" && busTypes && Object.keys(busTypes).length > 0) {
      for (const model in busTypes) {
        const ops = busTypes[model];
        if (ops[operator]?.includes(vehicleNumber)) {
          busType = model;
          color = vehicleColors.bus;
          break;
        }
      }
    }

    const popupContent = buildPopup(routeName, destination, vehicleLabel, busType, licensePlate, speedKmh, occupancy, bikesLine);

    if (vehicleLabel.startsWith("AM")) {
      if (typeKey === "train") inServiceAM.push({ vehicleId, lat, lon, speedKmh, vehicleLabel, color });
      else outOfServiceAM.push({ vehicleId, lat, lon, speedKmh, vehicleLabel });
    }

    addVehicleMarker(vehicleId, lat, lon, popupContent, color, typeKey, tripId);
    cachedState.push({ vehicleId, lat, lon, popupContent, color, typeKey, tripId, ts: Date.now() });
  });

  // AM pairing
  pairAMTrains(inServiceAM, outOfServiceAM).forEach(pair => {
    const inColor = pair.inTrain.color || vehicleColors.train;
    const outMarker = vehicleMarkers[pair.outTrain.vehicleId];
    if (outMarker) {
      outMarker.setStyle({ fillColor: inColor });
      const oldContent = outMarker.getPopup()?.getContent() || "";
      outMarker.getPopup().setContent(oldContent + `<br><b>Paired to:</b> ${pair.inTrain.vehicleLabel} (6-car)`);
    }
  });

  // Remove stale
  Object.keys(vehicleMarkers).forEach(id => {
    if (!newVehicleIds.has(id)) {
      map.removeLayer(vehicleMarkers[id]);
      delete vehicleMarkers[id];
    }
  });

  localStorage.setItem("realtimeSnapshot", JSON.stringify(cachedState));
  debugBox.textContent = `Realtime update complete at ${new Date().toLocaleTimeString()}`;
  updateVehicleCount();

  // Backfill trips async
  await fetchTripsBatch([...new Set(allTripIds)]);
  Object.values(vehicleMarkers).forEach(marker => {
    if (!marker.tripId) return;
    const tripData = tripCache[marker.tripId];
    if (tripData?.trip_headsign) {
      const old = marker.getPopup().getContent();
      // Replace fallback "Destination" with actual headsign
      if (old.includes("Destination:</b>") && !old.includes(tripData.trip_headsign)) {
        marker.setPopupContent(old.replace(/Destination:<\/b> .*?<br>/, `Destination:</b> ${tripData.trip_headsign}<br>`));
      }
    }
  });
}

// --- Init ---
async function init() {
  const routesJson = await safeFetch(routesUrl);
  if (routesJson?.data) {
    routesJson.data.forEach(r => {
      const attrs = r.attributes || r;
      routes[r.id] = {
        route_type: attrs.route_type,
        route_short_name: attrs.route_short_name,
        route_long_name: attrs.route_long_name,
        route_color: attrs.route_color,
        agency_id: attrs.agency_id
      };
    });
  }
  const busTypesJson = await safeFetch(busTypesUrl);
  if (busTypesJson) busTypes = busTypesJson;

  const cached = localStorage.getItem("realtimeSnapshot");
  if (cached) {
    try { renderFromCache(JSON.parse(cached)); } catch {}
  }

  fetchVehicles();
  setInterval(fetchVehicles, 15000);
}
init();
